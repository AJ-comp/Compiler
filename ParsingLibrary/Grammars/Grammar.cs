using ParsingLibrary.Datas.RegularGrammar;
using ParsingLibrary.Utilities;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;

namespace ParsingLibrary.Grammars
{
    public abstract class Grammar
    {
        private KeyManager keyManager = new KeyManager();

        /// <summary> first is character, second means whether ignore. true is ignoring. </summary>
        public Dictionary<char, bool> DelimiterDic { get; } = new Dictionary<char, bool>();

        public HashSet<NonTerminal> NonTerminalMultiples { get; } = new HashSet<NonTerminal>();
        public HashSet<NonTerminal> AutoGenerateNTSet { get; } = new HashSet<NonTerminal>();
        public HashSet<NonTerminalSingle> NonTerminalSingles { get; } = new HashSet<NonTerminalSingle>();

        public TerminalSet TerminalSet { get; } = new TerminalSet();
        public NonTerminal StartSymbol { get; private set; } = null;

        private string letter = "[a-zA-Z]";
        private string varLetter = "[_a-zA-Z]";

        public Grammar()
        {
//            this.Tokens.IdPattern = varLetter + "[_a-zA-Z0-9]*";
//            this.Tokens.LineCommentPattern = "//";
//            this.Tokens.BlockCommentPattern = "";

            this.DelimiterDic.Add(';', false);
            this.DelimiterDic.Add(',', false);
            this.DelimiterDic.Add('.', false);
            this.DelimiterDic.Add('=', false);
            this.DelimiterDic.Add('+', false);
            this.DelimiterDic.Add('-', false);
            this.DelimiterDic.Add('*', false);
            this.DelimiterDic.Add('/', false);
            this.DelimiterDic.Add('&', false);
            this.DelimiterDic.Add('|', false);
            this.DelimiterDic.Add('!', false);
            this.DelimiterDic.Add('(', false);
            this.DelimiterDic.Add(')', false);
            this.DelimiterDic.Add('[', false);
            this.DelimiterDic.Add(']', false);
            this.DelimiterDic.Add('{', false);
            this.DelimiterDic.Add('}', false);
            this.DelimiterDic.Add('?', false);
            this.DelimiterDic.Add('$', false);
            this.DelimiterDic.Add(' ', true);
            this.DelimiterDic.Add('\t', true);
            this.DelimiterDic.Add('\r', true);
            this.DelimiterDic.Add('\n', true);

            this.SetDataToHashSet();
        }

        private void SetDataToHashSet()
        {
            AutoGenerator.SetData(this, this.keyManager.NotDefinedKey, this.keyManager.EpsilonKey, this.keyManager.MarkerSymbolKey);

            Type type = this.GetType();

            BindingFlags Flags = BindingFlags.Instance
                                           | BindingFlags.GetField
                                           | BindingFlags.SetField
                                           | BindingFlags.NonPublic;

            this.TerminalSet.Add(new EndMarker());
            foreach (var member in type.GetFields(Flags))
            {
                if (member.FieldType.FullName == typeof(Terminal).ToString())
                {
                    Terminal param = member.GetValue(this) as Terminal;

                    this.keyManager.AllocateUniqueKey(param);
                    this.TerminalSet.Add(param);
                }
                else if (member.FieldType.FullName == typeof(NonTerminal).ToString())
                {
                    NonTerminal param = member.GetValue(this) as NonTerminal;

                    this.keyManager.AllocateUniqueKey(param);
                    this.NonTerminalMultiples.Add(param);
                    if (param.AutoGenerated) this.AutoGenerateNTSet.Add(param);
                }
            }

            foreach (var multipleNT in this.NonTerminalMultiples)
            {
                if (multipleNT.IsStartSymbol) this.StartSymbol = multipleNT;

                foreach (var singleNT in multipleNT) this.NonTerminalSingles.Add(singleNT as NonTerminalSingle);
            }
        }

        /// <summary>
        /// Delete the not referenced all symbols
        /// </summary>
        public void DelNotRefAllSymbols()
        {
            HashSet<NonTerminal> refSet = new HashSet<NonTerminal>();

            foreach (var item in this.NonTerminalMultiples) refSet.UnionWith(item.ToNonTerminalSet());
            var notRefSet = this.NonTerminalMultiples.Except(refSet).ToHashSet();

            this.NonTerminalMultiples.ExceptWith(notRefSet);
            this.AutoGenerateNTSet.ExceptWith(notRefSet);

            foreach (var symbol in notRefSet) this.keyManager.Remove(symbol);
        }

        /// <summary>
        /// Delete the not referenced symbols with auto-generated
        /// </summary>
        private void DelNotRefAGSymbolsCore()
        {
            HashSet<NonTerminal> refSet = new HashSet<NonTerminal>();

            foreach (var item in this.NonTerminalMultiples) refSet.UnionWith(item.ToNonTerminalSet());
            var notRefSet = this.AutoGenerateNTSet.Except(refSet).ToHashSet();

            this.NonTerminalMultiples.ExceptWith(notRefSet);
            this.AutoGenerateNTSet.ExceptWith(notRefSet);

            foreach (var symbol in notRefSet) this.keyManager.Remove(symbol);
        }

        /// <summary>
        /// Delete the not referenced symbols with auto-generated
        /// </summary>
        private void DelNotRefAGSymbols()
        {
            while (true)
            {
                var prevCnt = this.AutoGenerateNTSet.Count;
                this.DelNotRefAGSymbolsCore();

                if (prevCnt == this.AutoGenerateNTSet.Count) break;
            }
        }

        public void Optimization()
        {
            Optimizer.EliminateNeedlessAGNode(this.NonTerminalMultiples);
            this.DelNotRefAGSymbols();
        }

        /// <summary>
        /// Create a new symbol and designate a new symbol as the start symbol.
        /// </summary>
        /// <param name="newStartSymbolName">new start symbol name</param>
        public void ChangeStartSymbol(string newStartSymbolName)
        {
            NonTerminal newStartSymbol = new NonTerminal(newStartSymbolName, true);
            this.keyManager.AllocateUniqueKey(newStartSymbol);
            newStartSymbol.Add(this.StartSymbol);

            this.NonTerminalMultiples.Add(newStartSymbol);

            this.StartSymbol.IsStartSymbol = false;
            this.StartSymbol = newStartSymbol;
        }

        public NonTerminal CreateVirtualSymbolForLRParsing(string newSymbolName)
        {
            NonTerminal newSymbol = new NonTerminal(newSymbolName, true);
            this.keyManager.AllocateUniqueKey(newSymbol);
            newSymbol.Add(this.StartSymbol);

            this.NonTerminalMultiples.Add(newSymbol);

            return newSymbol;
        }

        public Terminal GetTerminal(string value) => this.TerminalSet.ContainFirst(value);

        public NonTerminal CreateAutoGeneratedNT()
        {
            string name = "G";

            for (int i = 1; i < 100000; i++)
            {
                bool findUniqueName = true;
                name += i.ToString();

                foreach (var nonTerminal in this.NonTerminalMultiples)
                {
                    if (nonTerminal.Name == name)
                    {
                        findUniqueName = false;
                        break;
                    }
                }

                if (findUniqueName) break;
            }

            var result = new NonTerminal(name, false, true);
            keyManager.AllocateUniqueKey(result);

            this.NonTerminalMultiples.Add(result);
            this.AutoGenerateNTSet.Add(result);

            return result;
        }
    }
}
