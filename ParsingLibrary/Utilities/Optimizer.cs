using ParsingLibrary.Datas;
using ParsingLibrary.Datas.RegularGrammar;
using System.Collections.Generic;

namespace ParsingLibrary.Utilities
{
    public class Optimizer
    {
        /// <summary>
        /// 대체가능한 비단말집합을 리턴한다 (단 하나의 NonTerminal 자식 노드만을 가진 경우)
        /// </summary>
        /// <returns></returns>
        public static ChangeableDataSet ChangeableNodeData(HashSet<NonTerminal> allNonTerminals)
        {
            ChangeableDataSet result = new ChangeableDataSet();

            foreach(var item in allNonTerminals)
            {
                // count of symbolList in the symbolListSet
                if (item.Count != 1) continue;

                // count of symbol in the symbolList
                var children = item.ElementAt(0);
                if (children.Count != 1) continue;

                Symbol symbol = children[0];
                if (symbol is Terminal) continue;

                NonTerminal child = (symbol as NonTerminal);
                if (child.IsStartSymbol) continue;

                NonTerminal key = result.ContainsElementOfValue(child);
                if (key != null) result[key].Add(item);
                else
                {
                    HashSet<NonTerminal> fromSet = new HashSet<NonTerminal>();
                    fromSet.Add(child);
                    result.Add(item, fromSet);
                }
            }

            return result;
        }

        private static bool IsAutoGenerated(Symbol src)
        {
            if (src is Terminal) return false;

            NonTerminal candidate = src as NonTerminal;
            if (!candidate.AutoGenerated) return false;

            return true;
        }

        /// <summary>
        /// only if exist one child node (nonterminal) (현재는 1depth만 본다)
        /// </summary>
        /// <param name="target"></param>
        /// <param name="explorationPreventSet"></param>
        /// <returns></returns>
        private static bool OptSingleChildNode(HashSet<NonTerminal> nonTerminals, NonTerminal target)
        {
            if (target.Count != 1) return false;

            NonTerminalSingle singleNT = target[0];

            if (singleNT.Count != 1) return false;
            if(singleNT[0] is Terminal) return false;

            var child = singleNT[0] as NonTerminal;
            if (!child.AutoGenerated) return false;

            target.SetChildrenOfItem(child);

            Analyzer.AllReplace(nonTerminals, child, target);

            return true;
        }

        /// <summary>
        /// https://www.lucidchart.com/documents/edit/ee28348d-60e1-4c50-b6ad-3b3f434ff026/0
        /// </summary>
        /// <param name="src"></param>
        /// <param name="explorationPreventSet"></param>
        /// <returns></returns>
        private static bool OptConcatNode(NonTerminal target, HashSet<NonTerminal> explorationPreventSet = null)
        {
            if (explorationPreventSet == null) explorationPreventSet = new HashSet<NonTerminal>();
            explorationPreventSet.Add(target);

            NonTerminal temp = target.Clone() as NonTerminal;
            target.Clear();

            foreach(NonTerminalSingle singleNT in temp)
            {
                SymbolList addList = new SymbolList();

                foreach (var symbol in singleNT)
                {
                    if (!Optimizer.IsAutoGenerated(symbol)) { addList.Add(symbol); continue; }

                    NonTerminal child = symbol as NonTerminal;

                    // 이미 탐색한 노드라면
                    if (explorationPreventSet.Contains(child)) { addList.Add(child); continue; }

                    if(Optimizer.OptConcatNode(child, explorationPreventSet))   addList.AddRange(child.ElementAt(0));
                    else addList.Add(child);
                }

//                if(addList.Count > 0) target.Children.Add(addList);
                target.Add(addList);
            }

            return (target.Count==1);
        }

        /// <summary>
        /// https://www.lucidchart.com/documents/edit/ee28348d-60e1-4c50-b6ad-3b3f434ff026/1
        /// </summary>
        /// <param name="target"></param>
        /// <param name="explorationPreventSet"></param>
        /// <returns></returns>
        private static bool OptAltNode(NonTerminal target, HashSet<NonTerminal> explorationPreventSet = null)
        {
            if (explorationPreventSet == null) explorationPreventSet = new HashSet<NonTerminal>();
            explorationPreventSet.Add(target);

            NonTerminal temp = target.Clone() as NonTerminal;
            target.Clear();

            foreach (NonTerminalSingle singleNT in temp)
            {
                SymbolList addList = new SymbolList();

                bool firstRule = (singleNT.Count == 1);
                foreach (var symbol in singleNT)
                {
                    if (!Optimizer.IsAutoGenerated(symbol)) { addList.Add(symbol); continue; }

                    NonTerminal child = symbol as NonTerminal;

                    // 이미 탐색한 노드라면
                    if (explorationPreventSet.Contains(child)) { addList.Add(child); continue; }

                    bool secondRule = Optimizer.OptAltNode(child, explorationPreventSet);
                    if (firstRule && secondRule) addList.AddRange(child.ElementAt(0));
                    else addList.Add(child);
                }

//                if(addList.Count > 0) target.Children.Add(addList);
                target.Add(addList);
            }

            return (target.Count > 1);
        }

        /// <summary>
        /// 자동생성된 노드 중 불필요한 노드들을 제거한다 (부모가 AG노드이고, ''SymbolList''가 1개일 경우에만 병합이 가능하다)
        /// Delete the needless nodes out of auto-generated
        /// </summary>
        /// <param name="target">최적화 대상 트리</param>
        /// <param name="explorationPreventSet">
        /// 탐색금지노드집합
        /// set that forbid exploration
        /// </param>
        public static void EliminateNeedlessAGNode(HashSet<NonTerminal> nonTerminals)
        {
            foreach (var target in nonTerminals)
            {
                Optimizer.OptSingleChildNode(nonTerminals, target);
                Optimizer.OptConcatNode(target);
                Optimizer.OptAltNode(target);
            }
        }
    }
}
