using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;

namespace ParsingLibrary.Datas.RegularGrammar
{
    public class NonTerminal : Symbol, IEnumerable<NonTerminalSingle>, ICloneable
    {
        private int position = -1;
        private SymbolListSet Children = new SymbolListSet();

        public bool IsStartSymbol { get; internal set; } = false;
        public bool AutoGenerated { get; } = false;
        public string Name { get; }
        public int Count => this.Children.Count;

        public NonTerminalSingle this[int index] => new NonTerminalSingle(this, index);

        public NonTerminal(string name, bool bStartSymbol = false, bool autoGenerated = false)
        {
            this.IsStartSymbol = bStartSymbol;
            this.Name = name;
            this.AutoGenerated = autoGenerated;
        }

        public NonTerminal(NonTerminal target)
        {
            this.uniqueKey = target.uniqueKey;

            this.IsStartSymbol = target.IsStartSymbol;
            this.Name = target.Name;
            this.AutoGenerated = target.AutoGenerated;
        }

        public NonTerminal(NonTerminalSingle single)
        {
            this.uniqueKey = single.UniqueKey;

            this.IsStartSymbol = single.IsStartSymbol;
            this.Name = single.Name;
            this.AutoGenerated = single.AutoGenerated;
        }

        public bool IsSubSet(NonTerminalSingle singleNT) => this.uniqueKey == singleNT.UniqueKey;

        /// <summary>
        /// Explore whether exist the item in the tree
        /// </summary>
        /// <param name="item"></param>
        /// <param name="breakSet"></param>
        /// <returns></returns>
        public bool IsContain(Symbol item, HashSet<NonTerminal> breakSet=null)
        {
            if (breakSet == null) breakSet = new HashSet<NonTerminal>();
            breakSet.Add(this);

            bool result = false;

            foreach(var symbolList in this.Children)
            {
                foreach (var symbol in symbolList)
                {
                    if (symbol == item)
                    {
                        result = true;
                        break;
                    }

                    if (symbol is Terminal) continue;

                    NonTerminal ntSymbol = symbol as NonTerminal;

                    // skip if it was searched the item
                    if (breakSet.Contains(ntSymbol)) continue;
                    result = ntSymbol.IsContain(item, breakSet);
                    if (result) break;
                }
            }

            return result;
        }

        public bool IsExistRefContent(NonTerminal target)
        {
            foreach(var symbolList in this.Children)
            {
                foreach (var symbol in symbolList)
                {
                    if (symbol is Terminal) continue;

                    NonTerminal nonTerminal = symbol as NonTerminal;

                    if (nonTerminal == target) return true;
                    else if (nonTerminal.IsExistRefContent(target)) return true;
                }
            }

            return false;
        }

        public void Clear() => this.Children.Clear();

        public void Add(NonTerminalSingle singleNT)
        {
            SymbolList param = new SymbolList();
            foreach (var data in singleNT)  param.Add(data);

            this.Children.Add(param);
        }

        public void Add(SymbolList symbols) => this.Children.Add(symbols);
        public void Add(params Symbol[] symbols) => this.Children.Add(new SymbolList(symbols));
        public void AddAsConcat(params Symbol[] symbols) => this.Children.AddAsConcat(symbols);
        public void AddAsAlter(params Symbol[] symbols) => this.Children.AddAsAlter(symbols);
        public void UnionWith(IEnumerable<SymbolList> other) => this.Children.UnionWith(other);

        public SymbolList ElementAt(int index) => this.Children.ElementAt(index);

        /// <summary>
        /// It allocate the children value of Nonterminal
        /// </summary>
        /// <param name="item"></param>
        /// <remarks>https://www.lucidchart.com/documents/edit/332a9afe-d053-4c13-ab2a-7110f25bff73/0</remarks>
        public void SetItem(NonTerminal item)
        {
            this.Children.Clear();
            this.Children.Add(new SymbolList(item));
        }

        public void SetChildrenOfItem(NonTerminal item)
        {
            this.Children.Clear();
            this.Children.UnionWith(item.Children);
        }

        public void SetChildren(Terminal item)
        {
            this.Children.Clear();
            this.Children.Add(new SymbolList(item));
        }

        public void Replace(NonTerminal from, NonTerminal to, SymbolSet breakSet = null)
        {
            if (breakSet == null) breakSet = new SymbolSet();
            breakSet.Add(this);

            NonTerminal temp = this.Clone() as NonTerminal;
            this.Children.Clear();

            foreach(var symbolList in temp.Children)
            {
                SymbolList addList = new SymbolList();

                foreach(var symbol in symbolList)
                {
                    if (symbol is Terminal) { addList.Add(symbol); continue; }

                    NonTerminal ntChild = symbol as NonTerminal;
                    if (ntChild == from) { addList.Add(to); continue; }
                    else addList.Add(ntChild);

                    if (ntChild == to) continue;
                    if (breakSet.Contains(ntChild)) continue;

                    ntChild.Replace(from, to, breakSet); // 아래 depth로 이동
                }

                this.Children.Add(addList);
            }
        }

        public HashSet<NonTerminal> ToNonTerminalSet() => this.Children.ToNonTerminalSet();


        public bool Equals(NonTerminal other)
        {
            if (object.ReferenceEquals(other, null)) return false;

            return (this.uniqueKey == other.uniqueKey);
        }


        public override string ToGrammarString()
        {
            string result = this.Name + " -> ";

            foreach (var symbolList in this.Children)
            {
                if (this.Children.Count > 1 && symbolList.Count > 1) result += "(";
                result += symbolList.ToString();
                if (this.Children.Count > 1 && symbolList.Count > 1) result += ")";

                result += Utilities.Convert.ToBridgeSymbol(BridgeType.Alternation);
            }

            return result.Substring(0, result.Length - Utilities.Convert.ToBridgeSymbol(BridgeType.Alternation).Length);
        }

        public override string ToTreeString(UInt16 depth = 1)
        {
            string result = string.Empty;

            for(int i=1; i<depth; i++)  result += "  ";

            result += "Nonterminal : " + this.Name + Environment.NewLine;

            foreach(var symbolList in this.Children)
            {
                foreach(var symbol in symbolList)
                {
                    for (int i = 1; i < depth; i++) result += "  ";
                    result += "  ";

                    if (symbol is Terminal) result += "Terminal : " + symbol.ToString();
                    else result += "NonTerminal : " + symbol.ToString();

                    result += Environment.NewLine;
                }
            }

            return result;
        }

        public override string ToString() => this.Name;

        public bool MoveNext()
        {
            if (this.position == this.Children.Count - 1)
            {
                this.Reset();
                return false;
            }
            return (++position < this.Children.Count);
        }

        public void Reset() => this.position = -1;

        IEnumerator<NonTerminalSingle> IEnumerable<NonTerminalSingle>.GetEnumerator()
        {
            for (int i = 0; i < this.Children.Count; i++)
            {
                yield return new NonTerminalSingle(this, i);
            }
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            throw new NotImplementedException();
        }

        public object Clone()
        {
            NonTerminal result = new NonTerminal(this);

            result.Children.UnionWith(this.Children);

            return result;
        }
    }
}
